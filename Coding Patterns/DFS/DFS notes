Preorder Traversal:
node --> node.left --> node.right

Inorder Traversal:
node.left --> node --> node.right

Postorder Traversal:
node.left --> node.right --> node


Bottom up DFS:
1. Base Case
2. Get Child/recursion return value
3. Use the child value to find the answer for current problem
4. (optional) if necessary, additional operation
5. return answer (to parent's problem)

Bottom up Problems:
104. Maximum depth of Binary tree
124. Binary Tree Maximum Path Sum


Top Down DFS:
1. Base Case
2. Use return value from the parent node to calculate
3. (optional) if necessary, additional operation
4. pass the return value to the child node and continue recursion (on child nodes)

Top Down problems:
129. Sum Root to Leaf numbers


DFS problems:
98. Validate Binary Search Tree
110. Balanced Binary Tree
113. Path Sum II
236. Lowest Common Ancestor of a Binary Tree
450. Delete Node in a BST
508. Most Frequent subtree sum

We will be using recursion (or we can also use a stack for the iterative approach) to keep track of all the previous
(parent) nodes while traversing. This also means that the space complexity of the algorithm will be O(H)O(H), where ‘H’
is the maximum height of the tree.